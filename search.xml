<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>再次开始</title>
    <url>/2020/10/07/time/</url>
    <content><![CDATA[<p> 常见错误： 文章头添加，后面一定要带空格。</p>
<blockquote class='blockquote-center'><p>完全不懂网页的家伙做起了博客，要感谢前人与如今互联网。</p>
</blockquote>

<p>（其实和别家的博客差不多吧？就是为了风格麻烦了点）</p>
]]></content>
  </entry>
  <entry>
    <title>逆向练习#1</title>
    <url>/2020/10/07/%E9%80%86%E5%90%91%E5%A4%8D%E4%B9%A01/</url>
    <content><![CDATA[<h1 id="BUUCTF-reverse1"><a href="#BUUCTF-reverse1" class="headerlink" title="[BUUCTF-reverse1]"></a>[BUUCTF-reverse1]</h1><p>逆向复习</p>
<p>1.打开IDA导入文件（其实首先要放入Exeinfo PE中查看信息）</p>
<p>2.shift+f12搜索关键字符串  如</p>
<h3 id="3-遇到问题-摸到字符串地址的时候-不能用f5查看伪代码-并且不能转换成框图-怀疑原因是ida没有识别出这些是函数"><a href="#3-遇到问题-摸到字符串地址的时候-不能用f5查看伪代码-并且不能转换成框图-怀疑原因是ida没有识别出这些是函数" class="headerlink" title="3.遇到问题  摸到字符串地址的时候  不能用f5查看伪代码  并且不能转换成框图  怀疑原因是ida没有识别出这些是函数"></a>3.遇到问题  摸到字符串地址的时候  不能用f5查看伪代码  并且不能转换成框图  怀疑原因是ida没有识别出这些是函数</h3><p>我曾经也遇到过这个问题。然而在百度的过程中，发现“Create Fun”方法并没有用。<img src="https://i.loli.net/2020/10/07/Lw6ithPkQGNR2Ad.png" alt="image-20201006171151959"></p>
<p>实际上，跟进下面sub_1400118C0地址，就能找到函数所在。（已然是框图显示）</p>
<a id="more"></a>

<p><img src="https://i.loli.net/2020/10/07/BZahbjKvrWynpM1.png" alt="image-20201006171251650"></p>
<p>F5查看loc_140011948的伪代码（改正：其实F5已经结合整个框图）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">int64 <span class="title">sub_1400118C0</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *v0; <span class="comment">// rdi</span></span><br><span class="line">  <span class="keyword">signed</span> __int64 i; <span class="comment">// rcx</span></span><br><span class="line">  <span class="keyword">size_t</span> v2; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">size_t</span> v3; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">char</span> v5; <span class="comment">// [rsp+0h] [rbp-20h]</span></span><br><span class="line">  <span class="keyword">int</span> j; <span class="comment">// [rsp+24h] [rbp+4h]</span></span><br><span class="line">  <span class="keyword">char</span> Str1; <span class="comment">// [rsp+48h] [rbp+28h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v8; <span class="comment">// [rsp+128h] [rbp+108h]</span></span><br><span class="line"></span><br><span class="line">  v0 = &amp;v5;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">82</span>i64; i; --i )</span><br><span class="line">  &#123;</span><br><span class="line">    *(_DWORD *)v0 = <span class="number">-858993460</span>;</span><br><span class="line">    v0 += <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ( j = <span class="number">0</span>; ; ++j )</span><br><span class="line">  &#123;</span><br><span class="line">    v8 = j;</span><br><span class="line">    v2 = j_strlen(Str2);</span><br><span class="line">    <span class="keyword">if</span> ( v8 &gt; v2 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( Str2[j] == <span class="number">111</span> )</span><br><span class="line">      Str2[j] = <span class="number">48</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  sub_1400111D1(<span class="string">&quot;input the flag:&quot;</span>);</span><br><span class="line">  sub_14001128F(<span class="string">&quot;%20s&quot;</span>, &amp;Str1);</span><br><span class="line">  v3 = j_strlen(Str2);</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strncmp</span>(&amp;Str1, Str2, v3) )</span><br><span class="line">    sub_1400111D1(<span class="string">&quot;this is the right flag!\n&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    sub_1400111D1(<span class="string">&quot;wrong flag\n&quot;</span>);</span><br><span class="line">  sub_14001113B(&amp;v5, &amp;unk_140019D00);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>i64;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据 if ( !strncmp(&amp;Str1, Str2, v3) ) 可以明白，这是让str1和str2比较。</p>
<p>跟进str2可以发现，flag就是{hello_world}</p>
<p><img src="https://i.loli.net/2020/10/07/yXOlJC9eDz3aYwv.png" alt="image-20201006172059661"></p>
<p>但根据上面的代码，会发现str2被处理过。</p>
<p><img src="https://i.loli.net/2020/10/07/WZrQfubdaRPL8Gs.png" alt="image-20201006172402838"></p>
<p>大意就是，从str2字符串第一位开始遍历到最后一位，如果是111，则变成48.</p>
<p>111和48是什么？  其实是ASCII码，选中后按R即可变成字母。（感谢之前瞎玩的经验）</p>
<p><img src="https://i.loli.net/2020/10/07/vuF7scm2hDawkEl.png" alt="image-20201006172536880"></p>
<p>所以很明显，实际上的flag就是flag{hell0_w0rld}。</p>
<p>思考：有无用dbg进行动态分析的方法？能不能直接从start函数跳转进目标函数？看伪代码其实是种捷径，但我连这种方法都忘了，并且这里面还有许多不懂的。</p>
<p>1.什么是DATA XREF</p>
<p>2.这个rdata的地址命名有什么含义</p>
<p>这个感觉，就好像直接右键记事本打开文件，然后搜索flag一样莫名其妙。大概就是要这样不断积累经验吧。</p>
<h4 id="PS：还有个致命问题，打开文件提示0xc000007b错误，无法打开，导致我不能放进dbg动态分析。想解决，为此浪费了许多时间，但都无果。"><a href="#PS：还有个致命问题，打开文件提示0xc000007b错误，无法打开，导致我不能放进dbg动态分析。想解决，为此浪费了许多时间，但都无果。" class="headerlink" title="PS：还有个致命问题，打开文件提示0xc000007b错误，无法打开，导致我不能放进dbg动态分析。想解决，为此浪费了许多时间，但都无果。"></a>PS：还有个致命问题，打开文件提示0xc000007b错误，无法打开，导致我不能放进dbg动态分析。想解决，为此浪费了许多时间，但都无果。</h4>]]></content>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>曾经的琐事（能留下来的，算是纪念）</title>
    <url>/2020/10/07/%E6%9B%BE%E7%BB%8F%E7%9A%84%E7%90%90%E4%BA%8B/</url>
    <content><![CDATA[<p>19.12.14</p>
<h4 id="荒废"><a href="#荒废" class="headerlink" title="荒废"></a>荒废</h4><p>一看时间已经过了两个多月多一点了，现在才想起我这个博客来。两个月该说长还是短呢？高中的时候希望时间过得快，大学的时候希望时间过得慢，可世间的一切希望都不是如人所愿的。尽管我觉得浪费时间没什么不好的，但生活中的教训会把“原地踏步就是落后”的烙铁印在你的身体里面，你闲下一刻都会觉得不安，可你又仍然选择无所作为。慕强狗，我是个慕强狗，我也是个懒狗。说好听点是充满上进心，懂得忙里偷闲，但我不喜欢这样，因为我被他束缚住了。所以我选择去接纳我自己，在放弃自己“所谓为人”的尊严，懒狗也好，慕强狗也罢，实际上什么都没起作用，生活没有改变，我依然会困了想睡觉饿了想吃饭，满足了这些后依然感到全身幸福。</p>
<p>以上大概没什么意义，未来的我翻开这个博客大概看不出什么深意，因为我本就没有什么深意，但我知道我是个会过度解读的人，而过度解读的我会给自己强行安置上进心，这不坏。</p>
<p>最后想说的就是我不知道这些会给谁看到，我内心是隐隐希望有人能看到的，也是隐隐希望有人能看到这些字而欣赏我的，甚至来和我聊天、成为知音。这些是不会发生的，但这不影响它成为一个美好的希冀，纯属是因为自己小时候看太多漫画被营造的浪漫情结深深吸引从而无限神往。</p>
<p>还没到最后。我想做的其实是技术记录向博客，不过偶尔会扔些心得shit吧，虽然这比在微博开个小号产shit要麻烦得多。但是要随性一点对吧。</p>
<p>其实最尴尬的是以后我可能会给熟人分享自己的博客，这倒是个值得思考的问题，这些作话要是给熟人看到了，他是怎么想的？对，你看到了吧！这就是我，越是了解一个人，就会越看到这个人产出shit。这要怪我外有隐瞒内而充满倾诉欲望。有些时候我是满足的，其实只是我把欲望的洞口粉饰了下而已。并且我觉得，我现在做得很好，这大概就是我最大的错误，而却无法改正，因为我以此为生。</p>
<a id="more"></a>

<p>19.12.17</p>
<h4 id="又是这样"><a href="#又是这样" class="headerlink" title="又是这样"></a>又是这样</h4><p>本来说要做技术学习的博客的，每天整理学习内容。又是这样荒废了</p>
<p>可是要整理什么呢？我好像完全没有这个能力，从何开始学起呢？</p>
<p>1.想到三问哥教的。描述一定要准确，提出一个要求，越准确越好，这样就更好的配合。比如要一个蒸汽朋克风格，就说要齿轮、蒸汽管道、破旧发黄的铁板等… 确实是适用，但我总觉得有些局限。</p>
<p>2.说话真的是很重要。我自认情商还不错，实际上只是以逃避来避免错误罢了。尽管说“君子于其所不知，盖阙如也”，可是交流有其必要性，和队友合作，和顾客交谈。交流不善，全部完蛋。特别是现在越来越需要交流了，也许大家都会认为一个人能做成很多事，而且文学里面都呼吁要一个人静静，发现本我。啊，多么文艺高雅，哼，周边的一群凡人。无能力的尚且如此，有能力的会是怎么样呢？他会把在需要合作的团队里保持独立看作是更加高尚更有助于游戏研发的一件事吗。人难免会骄傲，孤僻的人更难免。我有能力做到这些吗？</p>
<p>从具体的来讲，我大概是需要利用人们的心理弱点。比如战时的演讲和宣传，煽动情绪什么的。</p>
<p>20.4.13</p>
<h4 id="还是少说点废话"><a href="#还是少说点废话" class="headerlink" title="还是少说点废话"></a>还是少说点废话</h4><p>今个打开博客一看，两篇埋怨自己荒废时间的文章格外醒目。现在再一看时间，已经是四月了，不知是该哭还是该笑。哭的是自己总是在同一个地方跌倒，笑的是自己除了发发牢骚没什么实际行动。我想实际行动了，所以我在想这四个月来我是否有些进步？我是有做了一个小动画，做了一个小游戏，练习了一些绘画，写了一些ctf题目。但全都没有坚持下来，就比如这个博客，我必须得看一眼教程才能回想起来怎么上传。那么这就意味着，那些简单尝试过后的东西，没有坚持，没有反复，到时候重新拾起的时候，和从零开始没什么区别。</p>
<p>与其啰嗦，还是赶紧干点正事吧。先做好规划</p>
<p>从长远角度目标：1.学习信息安全专业知识 2.学习游戏策划</p>
<p>细化目标：</p>
<p>1.学习c语言和python 2.上课发的呆都要补回来 3.多问三问哥关于游戏策划的知识 4.每天背十单词 三句话</p>
<p><strong>重中之重</strong>：</p>
<p>1.每天坚持上博客 2.晚上的时候要回顾 3.周末抽时间做大复习，发报告到博客上面。</p>
<p>20.4.26</p>
<p>上一周没有总结，印象深刻的是那天晚上写了篇“章鱼烧”发出去，九点开始写，写完就十一点半了。</p>
<p>没有总结是一个很大的错误，虽然我很擅长给自己找借口，心想第一个星期错过就错过，下个星期再开始也说得过去，但我要明白我不能自欺欺人。</p>
<p>4.13 思考奶头乐理论</p>
<p>4.14 MECE分析法</p>
<p>4.15 思考“持之以恒”</p>
<p>4.16 边际效应</p>
<p>4.17 下五子棋结果忘记总结</p>
<p>4.18 看了叶问片段，反派三观不正却武艺高强，引发思考”德不配才“</p>
<p>4.19 章鱼烧</p>
<p>以上为学校的<strong>第八周</strong></p>
<p>4.20 早上要上课，结果一直在看漫画，反思</p>
<p>4.21 思考“理解的存在性与正确性”</p>
<p>4.22 有开始做明日方舟视频的想法</p>
<p>接下来开始混沌</p>
<p>4.23——4.25 早上LOL想要冲铂金，晚上R6。</p>
<p>4.26 明日方舟一周年了，早上看相关讨论看了两个小时多。</p>
<p>以上为学校的<strong>第九周</strong></p>
<p>1.我没有把该做的东西当作目标去做，就好像饿了特别想吃饭，难受了特别想倾诉。我的写作就出于这么一种原始的冲动，同时我也愿意去做。但做其他的事情就没有这样的动力了。就拿写作来比喻，我写一会儿心里就舒服一会儿，得到正反馈，就会一直做下去。可是写到末尾的时候，突然觉得全篇呓语，狗屁不通，顿时就失去了接下去写的动力，哪怕只剩个结尾了，也就陷入了“啊结尾该怎么写啊”，“好麻烦，好烂，不想写了”等泥潭中。所幸秉承有始有终的原则，硬着头皮把它写掉了。</p>
<p>但这样还是有问题：1.没有反复打磨的欲望 2.写的真的是狗屁不通！ 3.并没有因为写得不好就想着再写一篇</p>
<p>第2点的原因我觉得是因为脑袋空空，没有读书，没有滋养和补充，那当然写得不好。那没读书，是因为没时间。时间哪去了呢？打游戏，闲看去了。原本我心中鄙视看抖音的人，浪费时间看些没营养的短视频，然而我看b站，虽然都是些长视频也有营养，但我是没吸收什么营养，因为我回想的时候总想不起来我看了什么。那这样我就和那些人无异，为何鄙视呢？更不用说我把一天之中的大块时间拿来打游戏了。</p>
<p>初中的时候我就想着要有一种方法，让我能和打游戏和平共处，得出的结论是：从事游戏相关工作。而现在我是向游戏相关工作那方面靠了一点，让我有一种成功的错觉，实际上真的是一点点啊，人家大四毕业毫无经验培训一星期就把你反超的那种。那还有什么好自豪的呢？既然如此，打游戏的合理性就消失了，只剩下娱乐性。那么，时间分配给它就要少一点。</p>
<p>总结：1.采取强制措施，控制游戏时间 2.做感兴趣的事情要保有冲动 3.少闲看，抓紧零碎时间。</p>
<p>20.5.3</p>
<p>在5.4做5.3的总结 没错晚了一天</p>
<p>总的来说大有问题</p>
<p>4.27早晨写了一篇散文，回看后，我觉得这篇散文有点我想表达的味道出来。要更多的跳出自我的框架，放眼看更多的人和事。</p>
<p>4.28自己就算不打游戏，一样浪费时间。这天早上报复性地去尝试学习ctf，学了一点就自觉满意停下了。晚上没有回顾</p>
<p>4.29逆向解题总结，实际上根本没总结多少</p>
<p>4.30–5.3号 早上看电影 没事就闲逛看视频</p>
<p>5.4 想写文章 也写了 做c语言作业 很简单 但是拖了很久</p>
<p>4.22那天就想做明日方舟视频了，但是在5.4这天，仅仅是做了图，骨骼都没搭好。</p>
<p>这几天把博客设成主页，一点开浏览器就弹出来了，但是我没有选择去看</p>
<p>也许我的强制措施要更强烈一点？像父母严格要求自己的孩子？</p>
<p>写文章倒是抱有强烈的冲动，这样的话，看书也得有。看了很多评论，他们的言论真实且犀利，我觉得我需要有一种自成一体的解释方式。</p>
<p>5.10就是网鼎杯的比赛了 开学时间暂定 5.5晚上要交三问哥的总结 每天还要看游戏心理学</p>
<p>20.5.10</p>
<p>做5.10总结</p>
<p>5.4-5.5 五一假期 睡了玩玩了睡</p>
<p>5.6 记得有点清楚，早上醒来物理课打算补，结果又没补。</p>
<p>5.7–5.9 陷入了一个怪圈，这几天做makerspace实验室的交代工作，但是不太行，调整了下定位，不参加比赛了，跟着三问哥再去学习。其实我觉得，学的知识对游戏制作来说没有用。就好像我在学的是礼品包装，和做礼品不一样。很纠结，每天想着写ctf的题，写却是看到题目，马上看writeup，真的是完全不懂，但是不懂就算了，起码把writeup抄下来，每天再看一遍？</p>
<p>其中还抽空写了文章，写了三篇。其中有一篇《纯粹的》模仿迹象严重，但却是贴近我的表达欲望的，应该多模仿，同时尝试创新。</p>
<p>5.10 参加了网鼎杯的比赛。队友的学长们很厉害，能解出两道题，还有两道题py来的，也算是能力的一部分。确实学习了很多，比如解题方式、思路、场面状况，对于ctf比赛来讲，思路是很跳跃的，比如杂项，基本上大牛也是靠提示，很久才解决出来。但基本功要好，这样签到题、简单的逆向和密码学和pwn和web都能解出来，晋级的机会还是大的。虽然这么说，题目就那些，需要刷的题还需要更有针对性，最好以累年比赛的例题。</p>
<p>总结：1.现在每天都忘记记录了，一天做了什么，到了周末就难想清楚，要重新每天记录。</p>
<p>2.现在天气热了，应该多锻炼。原本每天一小时锻炼，现在却没了，反思。</p>
<p>3.其中还加了粉丝交流群，我觉得应该和别人多加讨论，一些问题和三问哥也应该多讨论。</p>
<p>4.每天反复这件事情，必须得加强。</p>
<p>20.5.17</p>
<p>这周算是gap周吧，GTA5居然白给了！彩六出了活动！还有无限火力！好多有趣的活动，还补了很多以前一直很想看的番。</p>
<p>5.10-5.17</p>
<p>每天都在玩，非常严重的那种，算是洒脱一把了。</p>
<p>陆续有了许多好事，非常高兴，实验室那边有了结果，不算好也不算坏。</p>
<p>要说有什么成绩，倒是按照汪姐的风格写了三篇散文，个人感觉都是独立写的，有一定的味道了，有些许进步</p>
<p>可是我这个博客是技术博客啊，大概以后还是转型生活博客好了…没什么好意思以后和别人说：自己一直是在积累记录的。现在看来，现在只是一点点记录，纠正歪曲的懒惰性格的可能性存在一丢丢，进步真说不上。</p>
<p>学校是不开学了，结果我这周高数都没怎么认真上，下周得进入复习状态了</p>
<p>本周flag</p>
<p>从周一来看，精神状态很差，首先必须十一点准备睡觉！保证精神！</p>
<p>1.每天看一道ctf题，抄writeup。（重点在</p>
<p>2.10.00-12.00和15.00-18.00必须专心学习</p>
<p>3.学习时间划一个小时给英语</p>
<p>20.5.24</p>
<p>5.18：</p>
<p>WEB新手题1： 记得按F12</p>
<p>WEB新手2：Robots协议</p>
<p>robots.txt是搜索引擎中访问网站的时候要查看的第一个文件。当一个搜索蜘蛛访问一个站点时，它会首先检查该站点根目录下是否存在robots.txt，如果存在，搜索机器人就会按照该文件中的内容来确定访问的范围；如果该文件不存在，所有的搜索蜘蛛将能够访问网站上所有没有被口令保护的页面。</p>
<p>解题过程：在网址/之后输入robots.txt 意为进入网页目录中的robots文件，进入后发现提示flag的文字，再在网址之后键入目标文件，得到flag。</p>
<p>5.19</p>
<p>对于学术圈外的人来说，学术似乎是一个孤独的职业，但圈中人则了解，研究是极具社交性的。<br>——《历史的逻辑》（Sewell, 2005）</p>
<p>5.20</p>
<p>昨天进XCTF进不去，今天把昨天给补掉吧。</p>
<p>知识点：网页备份文件</p>
<p>常见的备份文件后缀名有: <code>.git .svn .swp .svn .~ .bak .bash_history</code></p>
<p>土办法就是在网页地址后缀后加/index.php.备份文件名 一个一个试过来</p>
<p>但是还有一种扫后台的方法。</p>
<p>5.23</p>
<p>永远逃避着</p>
<p>如果要我去写一篇小说，我会写这小说里的人们一直都在逃避，逃避许多悬而未决的问题，逃避自我的性格审判，逃避他人的是非判断，单纯地顺应着本能，总结出自我的小小道理。这小说大概会很没意思，因为它充斥着我的极端幻想与自以为是。尽管我是渴望被别人欣赏的，但是我不习惯于迎合他人的品味。也许这正是一个我不愿去研究他人喜好的借口，一个逃避的借口。</p>
<p>我觉得自我十分矛盾的时候，我的选择是丢下它。好似看破红尘的大师指点我，叫我放下，给人一种自己看得很高很远的，开悟的错觉。但最后我又不得不捡起它，于是在一次又一次的丢弃与拾起中，我逐渐明白它成为我生命中不可或缺的一部分，像是一生的宿敌、随我诞生的胎记。结果我自然而然地选择去接受它，一种看似自愿实则被迫的接受，如同时日无多的人选择放弃治疗，似乎拥有着与病魔对抗的尊严。</p>
<p>5.24总结</p>
<p>这一周还是不行，每天一题也没坚持下来，估计只有当我gta5玩腻了才会学习吧，或者是被deadline逼的。</p>
<p>现在我感觉就是每天给自己写病历，一天天病情恶化下去，希望真的不是这样，但是需要行动的啊。</p>
]]></content>
      <tags>
        <tag>杂事</tag>
      </tags>
  </entry>
  <entry>
    <title>电脑重装后如何再搭建与备份hexo博客</title>
    <url>/2020/10/07/%E7%94%B5%E8%84%91%E9%87%8D%E8%A3%85%E5%90%8E%E5%A6%82%E4%BD%95%E5%86%8D%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>那时候就想着，这些东西应该丢不掉，然而再搭建还是有点麻烦。想着要不就用CSDN或者博客园吧，但果然还是写好直接上传更爽。</p>
<p>唉，痛快玩了几个月，总是试着挖掘出可有可无的答案。</p>
<p>实际上，我懂的东西不多，性格又懒散悲观，所以这一切结束后，还是得往前走。走啊，你妈的！</p>
<h4 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h4><p>下载Git 与 node配置环境  百度就可，一路next，也没什么需要特别注意的。傻瓜式一键配置。（不知道会不会出问题）</p>
<h4 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h4><p>配置name与email</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">git config --global user.name=<span class="string">&quot;你的名字&quot;</span></span><br><span class="line">git config --global user.email=<span class="string">&quot;你的邮箱&quot;</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h4 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h4><p>重新生成私匙添加至git</p>
<p><code>ssh-keygen -t rsa -C &quot;你的邮箱&quot;  </code>（一定要大写C）</p>
<p>.ssh目录下得到了两个文件：<code>id_rsa（私有秘钥）和id_rsa.pub（公有密钥）</code><br>一般都在C盘你自己的所在用户目录下的<code>./ssh</code>文件夹中</p>
<p>然后进入github用户的settings中找到ssh，添加新的就行了，旧的可以删掉。</p>
<h4 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h4><p>在git bash中输入 <code>ssh-T git@github.com</code></p>
<p>然后问你确实是否继续连接的时候选yes就ok啦！</p>
<h4 id="5"><a href="#5" class="headerlink" title="5."></a>5.</h4><p>然后要初始化hexo博客，在gitbash中输入 hexo init C:/hexo  (指定位置)</p>
<p>CD 进入安装位置，输入hexo server测试</p>
<h4 id="6"><a href="#6" class="headerlink" title="6."></a>6.</h4><p>在配置文件里贴上github地址就行了哦</p>
<h4 id="7"><a href="#7" class="headerlink" title="7."></a>7.</h4><p>从github上面把自己的源文件和主题下过来，然后悲哀地发现，github上面的其实是生成文件，和本地源文件关系不大。只能复制markdown了。既然如此就重新来过吧！要不换个主题？下次记得备份（落泪）</p>
<h2 id="关于备份"><a href="#关于备份" class="headerlink" title="关于备份"></a>关于备份</h2><h4 id="1-复制仓库地址，运行Git将仓库clone到本地"><a href="#1-复制仓库地址，运行Git将仓库clone到本地" class="headerlink" title="1.复制仓库地址，运行Git将仓库clone到本地"></a>1.复制仓库地址，运行Git将仓库clone到本地</h4><p><code>git clone your shh address</code></p>
<h4 id="2-在下好的文件夹中git-bash"><a href="#2-在下好的文件夹中git-bash" class="headerlink" title="2.在下好的文件夹中git bash"></a>2.在下好的文件夹中git bash</h4><p>依次输入</p>
<p><code>git add .</code></p>
<p><code>git commit -m &quot;n&quot;</code>（随便啥名字）</p>
<p><code>git push -u origin master </code></p>
<p>（此操作目的是把本地仓库push到github上面，如果没有使用密钥此步骤需要你输入帐号和密码）</p>
<h4 id="3-完事"><a href="#3-完事" class="headerlink" title="3.完事"></a>3.完事</h4><p>在github里打开仓库就能看见你上传的备份了。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>上传图片这个解释地特好！</p>
<p><a href="https://blog.csdn.net/alovelypeach/article/details/107576779">https://blog.csdn.net/alovelypeach/article/details/107576779</a></p>
<p>详细的解释</p>
<p><a href="https://blog.csdn.net/sinat_37781304/article/details/82729029">https://blog.csdn.net/sinat_37781304/article/details/82729029</a></p>
]]></content>
  </entry>
  <entry>
    <title>逆向练习#2</title>
    <url>/2020/10/07/%E9%80%86%E5%90%91%E5%A4%8D%E4%B9%A02/</url>
    <content><![CDATA[<h1 id="BUUCTF-Reverse2"><a href="#BUUCTF-Reverse2" class="headerlink" title="[BUUCTF-Reverse2]"></a>[BUUCTF-Reverse2]</h1><p>1.下载下来发现不是exe文件，放进Exeinfo PE中查看信息</p>
<p><img src="https://i.loli.net/2020/10/07/Syw7HTAML8uVr4l.png" alt="image-20201006175641359"></p>
<p>百度了一下elf文件是什么，不懂，先扔IDA里面试试。</p>
<p>2.放入IDA，发现有main函数，进去，flag一般都在main函数中。</p>
<p><img src="https://i.loli.net/2020/10/07/u7UMPLpkwraVxDn.png" alt="image-20201006175920561"></p>
<p>一眼就能看见关键信息，跟进F5。<a id="more"></a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> stat_loc; <span class="comment">// [rsp+4h] [rbp-3Ch]</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+8h] [rbp-38h]</span></span><br><span class="line">  <span class="keyword">__pid_t</span> pid; <span class="comment">// [rsp+Ch] [rbp-34h]</span></span><br><span class="line">  <span class="keyword">char</span> s2; <span class="comment">// [rsp+10h] [rbp-30h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v8; <span class="comment">// [rsp+28h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  v8 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  pid = fork();</span><br><span class="line">  <span class="keyword">if</span> ( pid )</span><br><span class="line">  &#123;</span><br><span class="line">    argv = (<span class="keyword">const</span> <span class="keyword">char</span> **)&amp;stat_loc;</span><br><span class="line">    waitpid(pid, &amp;stat_loc, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="built_in">strlen</span>(&amp;flag); ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *(&amp;flag + i) == <span class="number">105</span> || *(&amp;flag + i) == <span class="number">114</span> )</span><br><span class="line">        *(&amp;flag + i) = <span class="number">49</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;input the flag:&quot;</span>, argv);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%20s&quot;</span>, &amp;s2);</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(&amp;flag, &amp;s2) )</span><br><span class="line">    result = <span class="built_in">puts</span>(<span class="string">&quot;this is the right flag!&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    result = <span class="built_in">puts</span>(<span class="string">&quot;wrong flag!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，比较输入值r2与flag是否符合。</p>
<p>跟进字符串flag</p>
<p><img src="https://i.loli.net/2020/10/07/efOFs351pIlPJTb.png" alt="image-20201006180258640"></p>
<p>可见flag是 {hacking_for_fun}</p>
<p>老套路，这个flag也是要被处理一遍的。</p>
<p><img src="https://i.loli.net/2020/10/07/Jg9ucr6AtXheNS5.png" alt="image-20201006180421718"></p>
<p>Ascii码按R提前转换过了</p>
<p>代码的含义就是，遍历每一个字母，把i和r换成1。</p>
<p>所以真正的flag是flag{hack1ng_fo1_fun}</p>
<p>思考：看不懂*(&amp;flag+i)是什么意思，又有点似懂非懂，忘记c语言的指针了。呜呜呜。</p>
]]></content>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向练习#3</title>
    <url>/2020/10/07/%E9%80%86%E5%90%91%E7%BB%83%E4%B9%A0-3/</url>
    <content><![CDATA[<h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><p>老样子放进exeinfo中查看信息</p>
<p><img src="https://gitee.com/onm1wa1/photo/raw/master/image-20201007194820045.png" alt="image-20201007194820045"></p>
<p>这次是有UPX壳的哦。<a href="https://www.onlinedown.net/soft/634046.htm">于是从网上找了一个万能破壳器</a>，壳这方面的知识有所欠缺。不过现在先就把脱壳后的文件丢进IDA吧。如果不脱壳，程序里什么字都看不见？</p>
<p><img src="https://gitee.com/onm1wa1/photo/raw/master/image-20201007195519315.png" alt="image-20201007195519315"></p>
<h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><p>进去之后主函数的关键信息马上就露出来了</p>
<p><img src="https://gitee.com/onm1wa1/photo/raw/master/image-20201007195928668.png" alt="image-20201007195928668"></p>
<p>F5之后</p>
<p><img src="https://gitee.com/onm1wa1/photo/raw/master/image-20201007195947826.png" alt="image-20201007195947826"></p>
<p>能看出最后是判断V5和V4是否相同，v5就是输入值。v4是 HappyNewYear</p>
<p>这是道简单题，题目也明显提示了。把v4套个flag格式填题目，正确！</p>
<p>思考：壳是什么？脱壳的原理？</p>
]]></content>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向练习#4</title>
    <url>/2020/10/08/%E9%80%86%E5%90%91%E7%BB%83%E4%B9%A0-4/</url>
    <content><![CDATA[<h1 id="BUUCTF-xor"><a href="#BUUCTF-xor" class="headerlink" title="[BUUCTF-xor]"></a>[BUUCTF-xor]</h1><h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>认识了简单的伪代码之后，要开始看复杂的了。</p>
<h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><p>在exeinfo中确认信息后，放入ida，找到main函数，f5查看伪代码</p>
<p><img src="https://gitee.com/onm1wa1/photo/raw/master/image-20201008111053312.png" alt="image-20201008111053312"></p>
<p>直接从网上扒来的图，因为我第一眼真的看不懂啊呜呜</p>
<p>逻辑具体是：首先判断我们的输入v6长度是否为33，不是就进入label_12，下面可以看到就是返回”Failed”。</p>
<p>然后<code>i=1，v6[1]</code>代表从输入的第二位开始，<code>^=</code>表示异或（即xor）。即把两个数据二进制化，对位相同则输出0，不同输出1，再以输出的二进制转换回来。</p>
<p>例子：5和3转为二进制分别为：0101 、0011，异或结果0110，转换为十进制的6，即5^3=6.</p>
<p>但是<code>a^=b</code>是什么操作？应该是把异或好的数据赋值给a。</p>
<p>之后，比较<code>v6</code>与<code>global</code>，（33uLL我不明白什么意思，uLL应该是数据类型，unsiged Long Long，33应该就是长度吧，但不知道这里面为什么说的是前31位）</p>
<h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><p>跟进global，里面有一串存储数据aFKWOXZUPFVMDGH，再跟进</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__cstring:0000000100000F6E aFKWOXZUPFVMDGH db &#39;f&#39;,0Ah              ; DATA XREF: __data:_global↓o</span><br><span class="line">__cstring:0000000100000F6E                 db &#39;k&#39;,0Ch,&#39;w&amp;O.@&#39;,11h,&#39;x&#39;,0Dh,&#39;Z;U&#39;,11h,&#39;p&#39;,19h,&#39;F&#39;,1Fh,&#39;v&quot;M#D&#39;,0Eh,&#39;g&#39;</span><br><span class="line">__cstring:0000000100000F6E                 db 6,&#39;h&#39;,0Fh,&#39;G2O&#39;,0</span><br></pre></td></tr></table></figure>

<p>既然知道了求得global的原理是异或，那么就反着来求出flag。异或反运算就是再异或一次。</p>
<p><code>0Ah</code>，<code>0ch</code>这些其实是十六进制，其他为字符串。</p>
<p>于是写python脚本，第一位f是不变的，从第二位0Ah开始。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str1 = [<span class="string">&#x27;f&#x27;</span>, <span class="number">0x0A</span>, <span class="string">&#x27;k&#x27;</span>, <span class="number">0x0C</span>, <span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;&amp;&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;@&#x27;</span>, <span class="number">0x11</span>, <span class="string">&#x27;x&#x27;</span>, <span class="number">0x0D</span>, <span class="string">&#x27;Z&#x27;</span>, <span class="string">&#x27;;&#x27;</span>, <span class="string">&#x27;U&#x27;</span>, <span class="number">0x11</span>, <span class="string">&#x27;p&#x27;</span>, <span class="number">0x19</span>, <span class="string">&#x27;F&#x27;</span>, <span class="number">0x1F</span>, <span class="string">&#x27;v&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;&quot;&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="number">0x0E</span>, <span class="string">&#x27;g&#x27;</span>, <span class="number">6</span>, <span class="string">&#x27;h&#x27;</span>, <span class="number">0x0F</span>, <span class="string">&#x27;G&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;O&#x27;</span>]</span><br><span class="line"></span><br><span class="line">x = <span class="string">&#x27;f&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(str1)):</span><br><span class="line">    <span class="keyword">if</span> (isinstance(str1[i], str)):</span><br><span class="line">        <span class="keyword">if</span> (isinstance(str1[i - <span class="number">1</span>], str)):</span><br><span class="line">            x += chr(ord(str1[i]) ^ ord(str1[i - <span class="number">1</span>]))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            x += chr(ord(str1[i]) ^ str1[i - <span class="number">1</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        x += chr(str1[i] ^ ord(str1[i - <span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure>

<p>首先把我们的数据输入，把16进制的数据写成python能识别的。查看第i位是不是字符串类型，不是就让第二位和第一位异或，输出加在x后面。</p>
<p>ord表示把字符串转化为十进制数字，因为ord（）内只能是字符串类型，所以要先isinstance判断。</p>
<p>这个脚本其实有bug，连续两个数字就出错了。改正也很简单，最下面的else内改为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (isinstance(str1[i - <span class="number">1</span>], str)):</span><br><span class="line">    x += chr(str1[i] ^ ord(str1[i - <span class="number">1</span>]))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    x += chr(str1[i] ^ str1[i - <span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><p>得出结果，flag{QianQiuWanDai_YiTongJiangHu}，完事！</p>
]]></content>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向练习#5</title>
    <url>/2020/10/09/%E9%80%86%E5%90%91%E7%BB%83%E4%B9%A0-5/</url>
    <content><![CDATA[<h1 id="BUUCTF-Reverse3"><a href="#BUUCTF-Reverse3" class="headerlink" title="[BUUCTF-Reverse3]"></a>[BUUCTF-Reverse3]</h1><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><p>根据之前的经验，我觉得放进exeinfo、然后扔进ida找关键函数再f5的操作可以省略不写了。（成长了？其实是懒狗）</p>
<h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><p>亲爱的伪代码在这里</p>
<p><img src="https://gitee.com/onm1wa1/photo/raw/master/image-20201009183056688.png" alt="image-20201009183056688"></p>
<a id="more"></a>

<p>直接看得出“right flag”这里，肯定是让<code>Dest</code>与<code>Str2</code>进行比较。</p>
<p>而<code>Dest</code>是由输入的<code>Str</code>被函数<code>sub_4110BE</code>加密处理后得出的。（其实这里我一头雾水，是因为我不知道strcpy函数是复制字符串到dest）</p>
<p><code>str2</code>是e3nifIH9b_C@n@dH</p>
<p>然而还有一个步骤</p>
<p><img src="https://gitee.com/onm1wa1/photo/raw/master/image-20201009191230322.png" alt="image-20201009191230322"></p>
<p>意为让<code>Dest</code>每一位字符串都加上对应位置数字ascii码</p>
<p>所以解密之前每一位还得先减去对应位置的数字。</p>
<h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><p>那么跟进<code>sub_4110BE</code></p>
<p><img src="https://gitee.com/onm1wa1/photo/raw/master/image-20201009184705272.png" alt="image-20201009184705272"></p>
<p>再跟进</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *__cdecl <span class="title">sub_411AB0</span><span class="params">(<span class="keyword">char</span> *a1, <span class="keyword">unsigned</span> <span class="keyword">int</span> a2, <span class="keyword">int</span> *a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// STE0_4</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// STE0_4</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// STE0_4</span></span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// [esp+D4h] [ebp-38h]</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> i; <span class="comment">// [esp+E0h] [ebp-2Ch]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v9; <span class="comment">// [esp+ECh] [ebp-20h]</span></span><br><span class="line">  <span class="keyword">int</span> v10; <span class="comment">// [esp+ECh] [ebp-20h]</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> v11; <span class="comment">// [esp+ECh] [ebp-20h]</span></span><br><span class="line">  <span class="keyword">void</span> *Dst; <span class="comment">// [esp+F8h] [ebp-14h]</span></span><br><span class="line">  <span class="keyword">char</span> *v13; <span class="comment">// [esp+104h] [ebp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( !a1 || !a2 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  v9 = a2 / <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">signed</span> <span class="keyword">int</span>)(a2 / <span class="number">3</span>) % <span class="number">3</span> )</span><br><span class="line">    ++v9;</span><br><span class="line">  v10 = <span class="number">4</span> * v9;</span><br><span class="line">  *a3 = v10;</span><br><span class="line">  Dst = <span class="built_in">malloc</span>(v10 + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !Dst )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  j_memset(Dst, <span class="number">0</span>, v10 + <span class="number">1</span>);</span><br><span class="line">  v13 = a1;</span><br><span class="line">  v11 = a2;</span><br><span class="line">  v7 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( v11 &gt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    byte_41A144[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    byte_41A144[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    byte_41A144[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">3</span> &amp;&amp; v11 &gt;= <span class="number">1</span>; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      byte_41A144[i] = *v13;</span><br><span class="line">      --v11;</span><br><span class="line">      ++v13;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( !i )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">switch</span> ( i )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        *((_BYTE *)Dst + v7) = aAbcdefghijklmn[(<span class="keyword">signed</span> <span class="keyword">int</span>)(<span class="keyword">unsigned</span> __int8)byte_41A144[<span class="number">0</span>] &gt;&gt; <span class="number">2</span>];</span><br><span class="line">        v4 = v7 + <span class="number">1</span>;</span><br><span class="line">        *((_BYTE *)Dst + v4++) = aAbcdefghijklmn[((byte_41A144[<span class="number">1</span>] &amp; <span class="number">0xF0</span>) &gt;&gt; <span class="number">4</span>) | <span class="number">16</span> * (byte_41A144[<span class="number">0</span>] &amp; <span class="number">3</span>)];</span><br><span class="line">        *((_BYTE *)Dst + v4++) = aAbcdefghijklmn[<span class="number">64</span>];</span><br><span class="line">        *((_BYTE *)Dst + v4) = aAbcdefghijklmn[<span class="number">64</span>];</span><br><span class="line">        v7 = v4 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        *((_BYTE *)Dst + v7) = aAbcdefghijklmn[(<span class="keyword">signed</span> <span class="keyword">int</span>)(<span class="keyword">unsigned</span> __int8)byte_41A144[<span class="number">0</span>] &gt;&gt; <span class="number">2</span>];</span><br><span class="line">        v5 = v7 + <span class="number">1</span>;</span><br><span class="line">        *((_BYTE *)Dst + v5++) = aAbcdefghijklmn[((byte_41A144[<span class="number">1</span>] &amp; <span class="number">0xF0</span>) &gt;&gt; <span class="number">4</span>) | <span class="number">16</span> * (byte_41A144[<span class="number">0</span>] &amp; <span class="number">3</span>)];</span><br><span class="line">        *((_BYTE *)Dst + v5++) = aAbcdefghijklmn[((byte_41A144[<span class="number">2</span>] &amp; <span class="number">0xC0</span>) &gt;&gt; <span class="number">6</span>) | <span class="number">4</span> * (byte_41A144[<span class="number">1</span>] &amp; <span class="number">0xF</span>)];</span><br><span class="line">        *((_BYTE *)Dst + v5) = aAbcdefghijklmn[<span class="number">64</span>];</span><br><span class="line">        v7 = v5 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        *((_BYTE *)Dst + v7) = aAbcdefghijklmn[(<span class="keyword">signed</span> <span class="keyword">int</span>)(<span class="keyword">unsigned</span> __int8)byte_41A144[<span class="number">0</span>] &gt;&gt; <span class="number">2</span>];</span><br><span class="line">        v6 = v7 + <span class="number">1</span>;</span><br><span class="line">        *((_BYTE *)Dst + v6++) = aAbcdefghijklmn[((byte_41A144[<span class="number">1</span>] &amp; <span class="number">0xF0</span>) &gt;&gt; <span class="number">4</span>) | <span class="number">16</span> * (byte_41A144[<span class="number">0</span>] &amp; <span class="number">3</span>)];</span><br><span class="line">        *((_BYTE *)Dst + v6++) = aAbcdefghijklmn[((byte_41A144[<span class="number">2</span>] &amp; <span class="number">0xC0</span>) &gt;&gt; <span class="number">6</span>) | <span class="number">4</span> * (byte_41A144[<span class="number">1</span>] &amp; <span class="number">0xF</span>)];</span><br><span class="line">        *((_BYTE *)Dst + v6) = aAbcdefghijklmn[byte_41A144[<span class="number">2</span>] &amp; <span class="number">0x3F</span>];</span><br><span class="line">        v7 = v6 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  *((_BYTE *)Dst + v7) = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> Dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这家伙好厉害！我看不懂</p>
<p>于是百度，说是base64加密。这代码属实触及我的知识盲区，也许以后可以靠记忆？长得像这样的就拿base64套（雾）</p>
<p>其实代码里出现了好多次aAbcdefghijklmn，跟进去看看。</p>
<p><img src="https://gitee.com/onm1wa1/photo/raw/master/image-20201009185340604.png" alt="image-20201009185340604"></p>
<p>而这就是base64加密的关键</p>
<p>它是用64个可打印字符表示二进制所有数据方法。由于2的6次方等于64，所以可以用每6个位元为一个单元，对应某个可打印字符。我们知道三个字节有24个位元，就可以刚好对应于4个Base64单元，即3个字节需要用4个Base64的可打印字符来表示。在Base64中的可打印字符包括字母A-Z、a-z、数字0-9 ，这样共有62个字符，此外两个可打印符号在不同的系统中一般有所不同。但是，我们经常所说的Base64另外2个字符是：“+/”。</p>
<p>（我大致能理解，算课外拓展了，记得以前学过一遍。那个等于号是作后缀）</p>
<p>Python有base64加密解密的库，于是写脚本。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  base64</span><br><span class="line">str = <span class="string">&#x27;e3nifIH9b_C@n@dH&#x27;</span></span><br><span class="line">flag=<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(str)):</span><br><span class="line">    x = chr(ord(str[i]) - i)</span><br><span class="line">    flag+=x</span><br><span class="line">flag = base64.b64decode(flag)</span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure>

<p>先减去对应位置的数字，组成新的字符串，再对他进行base64解密。</p>
<p>得出flag{i_l0ve_you}</p>
<p>总结：以前看伪代码的时候感觉眼花缭乱的，比如我刚开始在纠结那个for循环，以及下面lowword等东西是啥。其实应该赶紧抓住重点，这大概要我不断写题积累吧。也许掌握C++可能会更好？</p>
]]></content>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>特难题折腾#1</title>
    <url>/2020/10/12/%E9%9A%BE%E9%A2%98%E6%8A%98%E8%85%BE-1/</url>
    <content><![CDATA[<h1 id="2019红帽杯-xx"><a href="#2019红帽杯-xx" class="headerlink" title="[2019红帽杯]xx"></a>[2019红帽杯]xx</h1><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><p>exeinfo查看信息，无壳，然后放入ida64位。</p>
<h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><p>找到关键字符串，跟进看伪代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">int64 __fastcall <span class="title">sub_1400011A0</span><span class="params">(__int64 a1, __int64 a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> __int64 v2; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">signed</span> __int64 v3; <span class="comment">// rax</span></span><br><span class="line">  __int64 v4; <span class="comment">// rax</span></span><br><span class="line">  __int64 v5; <span class="comment">// r11</span></span><br><span class="line">  __int128 *v6; <span class="comment">// r14</span></span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// edi</span></span><br><span class="line">  _BYTE *v8; <span class="comment">// rsi</span></span><br><span class="line">  <span class="keyword">char</span> v9; <span class="comment">// r10</span></span><br><span class="line">  <span class="keyword">int</span> v10; <span class="comment">// edx</span></span><br><span class="line">  __int64 v11; <span class="comment">// r8</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v12; <span class="comment">// rcx</span></span><br><span class="line">  <span class="keyword">signed</span> __int64 v13; <span class="comment">// rcx</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v14; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 i; <span class="comment">// rax</span></span><br><span class="line">  __int64 v16; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">size_t</span> v17; <span class="comment">// rsi</span></span><br><span class="line">  _BYTE *v18; <span class="comment">// rbx</span></span><br><span class="line">  _BYTE *v19; <span class="comment">// r9</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> v20; <span class="comment">// er11</span></span><br><span class="line">  <span class="keyword">char</span> *v21; <span class="comment">// r8</span></span><br><span class="line">  <span class="keyword">signed</span> __int64 v22; <span class="comment">// rcx</span></span><br><span class="line">  <span class="keyword">char</span> v23; <span class="comment">// al</span></span><br><span class="line">  <span class="keyword">signed</span> __int64 v24; <span class="comment">// r9</span></span><br><span class="line">  <span class="keyword">signed</span> __int64 v25; <span class="comment">// rdx</span></span><br><span class="line">  __int64 v26; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">size_t</span> Size; <span class="comment">// [rsp+20h] [rbp-48h]</span></span><br><span class="line">  __int128 v29; <span class="comment">// [rsp+28h] [rbp-40h]</span></span><br><span class="line">  <span class="keyword">int</span> v30; <span class="comment">// [rsp+38h] [rbp-30h]</span></span><br><span class="line">  <span class="keyword">int</span> v31; <span class="comment">// [rsp+3Ch] [rbp-2Ch]</span></span><br><span class="line">  <span class="keyword">int</span> Code[<span class="number">4</span>]; <span class="comment">// [rsp+40h] [rbp-28h]</span></span><br><span class="line">  <span class="keyword">int</span> v33; <span class="comment">// [rsp+50h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  *(_OWORD *)Code = <span class="number">0</span>i64;</span><br><span class="line">  v33 = <span class="number">0</span>;</span><br><span class="line">  sub_1400018C0(<span class="built_in">std</span>::<span class="built_in">cin</span>, a2, Code);</span><br><span class="line">  v2 = <span class="number">-1</span>i64;</span><br><span class="line">  v3 = <span class="number">-1</span>i64;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    ++v3;</span><br><span class="line">  <span class="keyword">while</span> ( *((_BYTE *)Code + v3) );</span><br><span class="line">  <span class="keyword">if</span> ( v3 != <span class="number">19</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    sub_140001620(<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot;error\n&quot;</span>);</span><br><span class="line">    _exit((<span class="keyword">unsigned</span> __int64)Code);</span><br><span class="line">  &#125;</span><br><span class="line">  v4 = sub_140001E5C(<span class="number">5u</span>i64);</span><br><span class="line">  v5 = *(_QWORD *)&amp;::Code;</span><br><span class="line">  v6 = (__int128 *)v4;</span><br><span class="line">  v7 = <span class="number">0</span>;</span><br><span class="line">  v8 = (_BYTE *)v4;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    v9 = v8[(_QWORD)Code - v4];</span><br><span class="line">    v10 = <span class="number">0</span>;</span><br><span class="line">    *v8 = v9;</span><br><span class="line">    v11 = <span class="number">0</span>i64;</span><br><span class="line">    v12 = <span class="number">-1</span>i64;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      ++v12;</span><br><span class="line">    <span class="keyword">while</span> ( *(_BYTE *)(v5 + v12) );</span><br><span class="line">    <span class="keyword">if</span> ( v12 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( v9 == *(_BYTE *)(v5 + v11) )</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        ++v10;</span><br><span class="line">        ++v11;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> ( v10 &lt; v12 );</span><br><span class="line">    &#125;</span><br><span class="line">    v13 = <span class="number">-1</span>i64;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      ++v13;</span><br><span class="line">    <span class="keyword">while</span> ( *(_BYTE *)(v5 + v13) );</span><br><span class="line">    <span class="keyword">if</span> ( v10 == v13 )</span><br><span class="line">      _exit(v5);</span><br><span class="line">    ++v8;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( (<span class="keyword">signed</span> __int64)&amp;v8[-v4] &lt; <span class="number">4</span> );</span><br><span class="line">  *(_BYTE *)(v4 + <span class="number">4</span>) = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    ++v2;</span><br><span class="line">  <span class="keyword">while</span> ( *((_BYTE *)Code + v2) );</span><br><span class="line">  v14 = <span class="number">0</span>i64;</span><br><span class="line">  v29 = *v6;</span><br><span class="line">  <span class="keyword">while</span> ( *((_BYTE *)&amp;v29 + v14) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !*((_BYTE *)&amp;v29 + v14 + <span class="number">1</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      ++v14;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( !*((_BYTE *)&amp;v29 + v14 + <span class="number">2</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      v14 += <span class="number">2</span>i64;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( !*((_BYTE *)&amp;v29 + v14 + <span class="number">3</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      v14 += <span class="number">3</span>i64;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    v14 += <span class="number">4</span>i64;</span><br><span class="line">    <span class="keyword">if</span> ( v14 &gt;= <span class="number">0x10</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ( i = v14 + <span class="number">1</span>; i &lt; <span class="number">0x10</span>; ++i )</span><br><span class="line">    *((_BYTE *)&amp;v29 + i) = <span class="number">0</span>;</span><br><span class="line">  v16 = sub_140001AB0(Code, v2, &amp;v29, &amp;Size);</span><br><span class="line">  v17 = Size;</span><br><span class="line">  v18 = (_BYTE *)v16;</span><br><span class="line">  v19 = (_BYTE *)sub_140001E5C(Size);</span><br><span class="line">  v20 = <span class="number">1</span>;</span><br><span class="line">  *v19 = v18[<span class="number">2</span>];</span><br><span class="line">  v21 = v19 + <span class="number">1</span>;</span><br><span class="line">  v19[<span class="number">1</span>] = *v18;</span><br><span class="line">  v19[<span class="number">2</span>] = v18[<span class="number">3</span>];</span><br><span class="line">  v19[<span class="number">3</span>] = v18[<span class="number">1</span>];</span><br><span class="line">  v19[<span class="number">4</span>] = v18[<span class="number">6</span>];</span><br><span class="line">  v19[<span class="number">5</span>] = v18[<span class="number">4</span>];</span><br><span class="line">  v19[<span class="number">6</span>] = v18[<span class="number">7</span>];</span><br><span class="line">  v19[<span class="number">7</span>] = v18[<span class="number">5</span>];</span><br><span class="line">  v19[<span class="number">8</span>] = v18[<span class="number">10</span>];</span><br><span class="line">  v19[<span class="number">9</span>] = v18[<span class="number">8</span>];</span><br><span class="line">  v19[<span class="number">10</span>] = v18[<span class="number">11</span>];</span><br><span class="line">  v19[<span class="number">11</span>] = v18[<span class="number">9</span>];</span><br><span class="line">  v19[<span class="number">12</span>] = v18[<span class="number">14</span>];</span><br><span class="line">  v19[<span class="number">13</span>] = v18[<span class="number">12</span>];</span><br><span class="line">  v19[<span class="number">14</span>] = v18[<span class="number">15</span>];</span><br><span class="line">  v19[<span class="number">15</span>] = v18[<span class="number">13</span>];</span><br><span class="line">  v19[<span class="number">16</span>] = v18[<span class="number">18</span>];</span><br><span class="line">  v19[<span class="number">17</span>] = v18[<span class="number">16</span>];</span><br><span class="line">  v19[<span class="number">18</span>] = v18[<span class="number">19</span>];</span><br><span class="line">  v19[<span class="number">19</span>] = v18[<span class="number">17</span>];</span><br><span class="line">  v19[<span class="number">20</span>] = v18[<span class="number">22</span>];</span><br><span class="line">  v19[<span class="number">21</span>] = v18[<span class="number">20</span>];</span><br><span class="line">  v19[<span class="number">22</span>] = v18[<span class="number">23</span>];</span><br><span class="line">  <span class="keyword">for</span> ( v19[<span class="number">23</span>] = v18[<span class="number">21</span>]; v20 &lt; v17; ++v21 )</span><br><span class="line">  &#123;</span><br><span class="line">    v22 = <span class="number">0</span>i64;</span><br><span class="line">    <span class="keyword">if</span> ( v20 / <span class="number">3</span> &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v23 = *v21;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">        v23 ^= v19[v22++];</span><br><span class="line">        *v21 = v23;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> ( v22 &lt; v20 / <span class="number">3</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    ++v20;</span><br><span class="line">  &#125;</span><br><span class="line">  *(_QWORD *)&amp;v29 = <span class="number">-4569681940847739698</span>i64;</span><br><span class="line">  v24 = v19 - (_BYTE *)&amp;v29;</span><br><span class="line">  *((_QWORD *)&amp;v29 + <span class="number">1</span>) = <span class="number">3819887636644928495</span>i64;</span><br><span class="line">  v25 = <span class="number">0</span>i64;</span><br><span class="line">  v30 = <span class="number">-939386845</span>;</span><br><span class="line">  v31 = <span class="number">-95004953</span>;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( *((_BYTE *)&amp;v29 + v25) != *((_BYTE *)&amp;v29 + v25 + v24) )</span><br><span class="line">      _exit(v7 * v7);</span><br><span class="line">    ++v7;</span><br><span class="line">    ++v25;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v25 &lt; <span class="number">24</span> );</span><br><span class="line">  v26 = sub_140001620(<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot;You win!&quot;</span>);</span><br><span class="line">  <span class="built_in">std</span>::basic_ostream&lt;<span class="keyword">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;::<span class="keyword">operator</span>&lt;&lt;(v26, sub_1400017F0);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>i64;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>真的是很难了…</p>
<a id="more"></a>

<p>检索网上的资料，需要用IDA的findcrypt3插件。这个插件可以识别代码的特征，看出是什么类型的加密。</p>
<p>然而插件安装及其复杂，折腾了好久。想知道会不会有神仙能直接肉眼识别出加密类型呢？</p>
<h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><p>根据findcrypt插件查明为tea加密，进函数内部发现为xxtea加密。（查阅资料明白的，我觉得可以单独拿出来学一遍了）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">sub_1400011A0</span><span class="params">(__int64 a1, __int64 a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">signed</span> __int64 v3; <span class="comment">// rax</span></span><br><span class="line">  __int128 *v4; <span class="comment">// rax</span></span><br><span class="line">  __int64 v5; <span class="comment">// r11</span></span><br><span class="line">  __int128 *v6; <span class="comment">// r14</span></span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// edi</span></span><br><span class="line">  __int128 *v8; <span class="comment">// rsi</span></span><br><span class="line">  <span class="keyword">char</span> v9; <span class="comment">// r10</span></span><br><span class="line">  <span class="keyword">int</span> v10; <span class="comment">// edx</span></span><br><span class="line">  __int64 v11; <span class="comment">// r8</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v12; <span class="comment">// rcx</span></span><br><span class="line">  <span class="keyword">signed</span> __int64 v13; <span class="comment">// rcx</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v14; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 i; <span class="comment">// rax</span></span><br><span class="line">  _BYTE *v16; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">size_t</span> v17; <span class="comment">// rsi</span></span><br><span class="line">  _BYTE *v18; <span class="comment">// rbx</span></span><br><span class="line">  _BYTE *v19; <span class="comment">// r9</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> v20; <span class="comment">// er11</span></span><br><span class="line">  <span class="keyword">char</span> *v21; <span class="comment">// r8</span></span><br><span class="line">  <span class="keyword">signed</span> __int64 v22; <span class="comment">// rcx</span></span><br><span class="line">  <span class="keyword">char</span> v23; <span class="comment">// al</span></span><br><span class="line">  <span class="keyword">signed</span> __int64 v24; <span class="comment">// r9</span></span><br><span class="line">  <span class="keyword">signed</span> __int64 v25; <span class="comment">// rdx</span></span><br><span class="line">  __int64 v26; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">size_t</span> Size; <span class="comment">// [rsp+20h] [rbp-48h]</span></span><br><span class="line">  __int128 v29; <span class="comment">// [rsp+28h] [rbp-40h]</span></span><br><span class="line">  <span class="keyword">int</span> v30; <span class="comment">// [rsp+38h] [rbp-30h]</span></span><br><span class="line">  <span class="keyword">int</span> v31; <span class="comment">// [rsp+3Ch] [rbp-2Ch]</span></span><br><span class="line">  <span class="keyword">int</span> user_input[<span class="number">4</span>]; <span class="comment">// [rsp+40h] [rbp-28h]</span></span><br><span class="line">  <span class="keyword">int</span> v33; <span class="comment">// [rsp+50h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  *(_OWORD *)user_input = <span class="number">0</span>i64;</span><br><span class="line">  v33 = <span class="number">0</span>;</span><br><span class="line">  sub_1400018C0(<span class="built_in">std</span>::<span class="built_in">cin</span>, a2, user_input);      <span class="comment">// 读取用户输入</span></span><br><span class="line">  v2 = <span class="number">-1</span>i64;</span><br><span class="line">  v3 = <span class="number">-1</span>i64;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    ++v3;</span><br><span class="line">  <span class="keyword">while</span> ( *((_BYTE *)user_input + v3) );        <span class="comment">// 计算user_input（原为Code）的长度，即v3</span></span><br><span class="line">  <span class="keyword">if</span> ( v3 != <span class="number">19</span> )                               <span class="comment">// 输入的长度要等于19</span></span><br><span class="line">  &#123;</span><br><span class="line">    sub_140001620(<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot;error\n&quot;</span>);</span><br><span class="line">    _exit((<span class="keyword">unsigned</span> __int64)user_input);</span><br><span class="line">  &#125;</span><br><span class="line">  v4 = (__int128 *)sub_140001E5C(<span class="number">5u</span>i64);        <span class="comment">// v4为动态分配出的一块长度为5的空间</span></span><br><span class="line">  v5 = *(_QWORD *)&amp;Code;                        <span class="comment">// v5为内存中存储的数据</span></span><br><span class="line">                                                <span class="comment">//为&quot;qwertyuiopasdfghjklzxcvbnm1234567890&quot;</span></span><br><span class="line">  v6 = v4;</span><br><span class="line">  v7 = <span class="number">0</span>;</span><br><span class="line">  v8 = v4;                                      <span class="comment">// v6=v8=v4</span></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    v9 = *((_BYTE *)v8 + (<span class="keyword">char</span> *)user_input - (<span class="keyword">char</span> *)v4);<span class="comment">// v9 = user_input</span></span><br><span class="line">    v10 = <span class="number">0</span>;</span><br><span class="line">    *(_BYTE *)v8 = v9;</span><br><span class="line">    v11 = <span class="number">0</span>i64;</span><br><span class="line">    v12 = <span class="number">-1</span>i64;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      ++v12;</span><br><span class="line">    <span class="keyword">while</span> ( *(_BYTE *)(v5 + v12) );             <span class="comment">// v12  计算内存中存储数据的长度</span></span><br><span class="line">    <span class="keyword">if</span> ( v12 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( v9 == *(_BYTE *)(v5 + v11) )       <span class="comment">// 输入的字符，是在内存存储的数据里中的一个元素</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        ++v10;</span><br><span class="line">        ++v11;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> ( v10 &lt; v12 );</span><br><span class="line">    &#125;</span><br><span class="line">    v13 = <span class="number">-1</span>i64;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      ++v13;</span><br><span class="line">    <span class="keyword">while</span> ( *(_BYTE *)(v5 + v13) );             <span class="comment">// v12  计算内存中存储数据的长度</span></span><br><span class="line">    <span class="keyword">if</span> ( v10 == v13 )</span><br><span class="line">      _exit(v5);</span><br><span class="line">    v8 = (__int128 *)((<span class="keyword">char</span> *)v8 + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( (<span class="keyword">char</span> *)v8 - (<span class="keyword">char</span> *)v4 &lt; <span class="number">4</span> );        <span class="comment">// 54~83行</span></span><br><span class="line">                                                <span class="comment">// 输入数据的前四个元素能在内存中存储的数据中找到对应</span></span><br><span class="line">  *((_BYTE *)v4 + <span class="number">4</span>) = <span class="number">0</span>;                       <span class="comment">// v4这块动态分配的内存空间中存放着 输入的前四个元素和一个0</span></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    ++v2;</span><br><span class="line">  <span class="keyword">while</span> ( *((_BYTE *)user_input + v2) );        <span class="comment">// v2为输入字符串的长度</span></span><br><span class="line">  v14 = <span class="number">0</span>i64;</span><br><span class="line">  v29 = *v6;                                    <span class="comment">// v6等于v4   85行</span></span><br><span class="line">  <span class="keyword">while</span> ( *((_BYTE *)&amp;v29 + v14) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !*((_BYTE *)&amp;v29 + v14 + <span class="number">1</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      ++v14;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( !*((_BYTE *)&amp;v29 + v14 + <span class="number">2</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      v14 += <span class="number">2</span>i64;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( !*((_BYTE *)&amp;v29 + v14 + <span class="number">3</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      v14 += <span class="number">3</span>i64;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    v14 += <span class="number">4</span>i64;</span><br><span class="line">    <span class="keyword">if</span> ( v14 &gt;= <span class="number">16</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ( i = v14 + <span class="number">1</span>; i &lt; <span class="number">16</span>; ++i )</span><br><span class="line">    *((_BYTE *)&amp;v29 + i) = <span class="number">0</span>;                   <span class="comment">// 将四个字符之后的置零</span></span><br><span class="line">  v16 = sub_140001AB0((__int64)user_input, v2, (<span class="keyword">unsigned</span> __int8 *)&amp;v29, &amp;Size);                                         <span class="comment">//xxtea加密</span></span><br><span class="line">  v17 = Size;                                   <span class="comment">// 加密后的长度</span></span><br><span class="line">  v18 = v16;</span><br><span class="line">  v19 = sub_140001E5C(Size);                    <span class="comment">// 动态分配一块加密后字符串长度给v19</span></span><br><span class="line">  v20 = <span class="number">1</span>;</span><br><span class="line">  *v19 = v18[<span class="number">2</span>];</span><br><span class="line">  v21 = v19 + <span class="number">1</span>;</span><br><span class="line">  v19[<span class="number">1</span>] = *v18;</span><br><span class="line">  v19[<span class="number">2</span>] = v18[<span class="number">3</span>];</span><br><span class="line">  v19[<span class="number">3</span>] = v18[<span class="number">1</span>];</span><br><span class="line">  v19[<span class="number">4</span>] = v18[<span class="number">6</span>];</span><br><span class="line">  v19[<span class="number">5</span>] = v18[<span class="number">4</span>];</span><br><span class="line">  v19[<span class="number">6</span>] = v18[<span class="number">7</span>];</span><br><span class="line">  v19[<span class="number">7</span>] = v18[<span class="number">5</span>];</span><br><span class="line">  v19[<span class="number">8</span>] = v18[<span class="number">10</span>];</span><br><span class="line">  v19[<span class="number">9</span>] = v18[<span class="number">8</span>];</span><br><span class="line">  v19[<span class="number">10</span>] = v18[<span class="number">11</span>];</span><br><span class="line">  v19[<span class="number">11</span>] = v18[<span class="number">9</span>];</span><br><span class="line">  v19[<span class="number">12</span>] = v18[<span class="number">14</span>];</span><br><span class="line">  v19[<span class="number">13</span>] = v18[<span class="number">12</span>];</span><br><span class="line">  v19[<span class="number">14</span>] = v18[<span class="number">15</span>];</span><br><span class="line">  v19[<span class="number">15</span>] = v18[<span class="number">13</span>];</span><br><span class="line">  v19[<span class="number">16</span>] = v18[<span class="number">18</span>];</span><br><span class="line">  v19[<span class="number">17</span>] = v18[<span class="number">16</span>];</span><br><span class="line">  v19[<span class="number">18</span>] = v18[<span class="number">19</span>];</span><br><span class="line">  v19[<span class="number">19</span>] = v18[<span class="number">17</span>];</span><br><span class="line">  v19[<span class="number">20</span>] = v18[<span class="number">22</span>];</span><br><span class="line">  v19[<span class="number">21</span>] = v18[<span class="number">20</span>];</span><br><span class="line">  v19[<span class="number">22</span>] = v18[<span class="number">23</span>];                            <span class="comment">// 排序</span></span><br><span class="line">  <span class="keyword">for</span> ( v19[<span class="number">23</span>] = v18[<span class="number">21</span>]; v20 &lt; v17; ++v21 )   <span class="comment">// v21=v19+1</span></span><br><span class="line">  &#123;</span><br><span class="line">    v22 = <span class="number">0</span>i64;</span><br><span class="line">    <span class="keyword">if</span> ( v20 / <span class="number">3</span> &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v23 = *v21;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">        v23 ^= v19[v22++];</span><br><span class="line">        *v21 = v23;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> ( v22 &lt; v20 / <span class="number">3</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    ++v20;</span><br><span class="line">  &#125;</span><br><span class="line">  *(_QWORD *)&amp;v29 = <span class="number">0xC0953A7C6B40BCCE</span>i64;</span><br><span class="line">  v24 = v19 - (_BYTE *)&amp;v29;</span><br><span class="line">  *((_QWORD *)&amp;v29 + <span class="number">1</span>) = <span class="number">0x3502F79120209BEF</span>i64;</span><br><span class="line">  v25 = <span class="number">0</span>i64;</span><br><span class="line">  v30 = <span class="number">0xC8021823</span>;</span><br><span class="line">  v31 = <span class="number">0xFA5656E7</span>;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( *((_BYTE *)&amp;v29 + v25) != *((_BYTE *)&amp;v29 + v25 + v24) )</span><br><span class="line">      _exit(v7 * v7);</span><br><span class="line">    ++v7;</span><br><span class="line">    ++v25;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v25 &lt; <span class="number">24</span> );</span><br><span class="line">  v26 = sub_140001620(<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot;You win!&quot;</span>);</span><br><span class="line">  <span class="built_in">std</span>::basic_ostream&lt;<span class="keyword">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;::<span class="keyword">operator</span>&lt;&lt;(v26, sub_1400017F0);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>i64;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>*添加了注释的伪代码</p>
<p>流程为</p>
<ol>
<li><p>先判断输入的字符串是否都在程序实现存储的数据Code中（实际上我的IDA直接识别出在Code里了）</p>
</li>
<li><p>然后取前四个字符作为xxtea的密钥（因为格式是flag{}，所以密钥是flag，不满位数右端补零）</p>
</li>
<li><p>然后对输入的字符串进行加密（进行xxTEA加密，原理没搞懂，但是python有解密脚本）</p>
</li>
<li><p>之后对加密的字符串打乱顺序（伪代码排序部分）</p>
</li>
<li><p>之后异或操作（所以再异或一遍）</p>
</li>
<li><p>再与存储的数据进行比对（为CEBC406B7C3A95C0EF9B202091F70235231802C8E75656FA）</p>
<p>存储的数据也需要一定的知识，v29，v29+1，v30，v31在栈上存放的位置相连。小端序存放，需将其反过来写。</p>
<p>(感觉自己的学习跨度有点大了，以上东西理解了很久。涉及了许多知识。)</p>
</li>
</ol>
<h3 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h3><p>于是写python脚本。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data0 = <span class="string">&quot;CEBC406B7C3A95C0EF9B202091F70235231802C8E75656FA&quot;</span><span class="comment">#为提取出来的v29,v29+1,v30,v31</span></span><br><span class="line">data = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(data0),<span class="number">2</span>):</span><br><span class="line">    data.append(int(data0[i]+data0[i+<span class="number">1</span>],<span class="number">16</span>))<span class="comment">#每两位为整体，将16进制转换为10进制</span></span><br><span class="line">print(data)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(data)<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i//<span class="number">3</span>):</span><br><span class="line">        data[i] ^= data[j]</span><br><span class="line">        <span class="comment">#进行的异或操作</span></span><br><span class="line">print(data)</span><br><span class="line">biao = [<span class="number">2</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="number">9</span>,<span class="number">14</span>,<span class="number">12</span>,<span class="number">15</span>,<span class="number">13</span>,<span class="number">18</span>,<span class="number">16</span>,<span class="number">19</span>,<span class="number">17</span>,<span class="number">22</span>,<span class="number">20</span>,<span class="number">23</span>,<span class="number">21</span>]<span class="comment">#置换表</span></span><br><span class="line">shuju = [<span class="number">1</span>]*<span class="number">24</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">24</span>):</span><br><span class="line">    shuju[biao[i]] = data[i]<span class="comment">#将其按照一定顺序置换</span></span><br><span class="line">print(shuju)</span><br><span class="line">print(len(shuju))</span><br></pre></td></tr></table></figure>

<p>然后把置换回来的数据（参考博客原作者突然又用C）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;encode.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">	<span class="keyword">int</span> i,j,data[] = &#123; <span class="number">188</span>, <span class="number">165</span>, <span class="number">206</span>, <span class="number">64</span>, <span class="number">244</span>, <span class="number">178</span>, <span class="number">178</span>, <span class="number">231</span>, <span class="number">169</span>, <span class="number">18</span>, <span class="number">157</span>, <span class="number">18</span>, <span class="number">174</span>, <span class="number">16</span>, <span class="number">200</span>, <span class="number">91</span>, <span class="number">61</span>, <span class="number">215</span>, <span class="number">6</span>, <span class="number">29</span>, <span class="number">220</span>, <span class="number">112</span>, <span class="number">248</span>, <span class="number">220</span> &#125;;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++)<span class="comment">//导出加密的数据，将其转换为十六进制并用小端序来表示</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;0x&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span> (j = i * <span class="number">4</span> - <span class="number">1</span>; j &gt; (i - <span class="number">1</span>) * <span class="number">4</span> - <span class="number">1</span>; j--)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%x&quot;</span>, data[j]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n0x&quot;</span>);</span><br><span class="line">	<span class="keyword">int</span> key[] = &#123; <span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;g&#x27;</span> &#125;;<span class="comment">//导出密钥，将其转换为十六进制并用小端序来表示</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">3</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%x&quot;</span>, key[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)<span class="comment">//密钥为4个32位的数，1个字符4bit，4个字符为32bit，还差3个32bit的数</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;0x0,&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">uint32_t</span> enc[<span class="number">6</span>] = &#123; (<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="number">0x40cea5bc</span>,(<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="number">0xe7b2b2f4</span>,(<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="number">0x129d12a9</span>,(<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="number">0x5bc810ae</span>,(<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="number">0x1d06d73d</span>,(<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="number">0xdcf870dc</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="number">-6</span>;</span><br><span class="line">	<span class="keyword">uint32_t</span> <span class="keyword">const</span> key[<span class="number">4</span>] = &#123; (<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="number">0x67616c66</span>,(<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="number">0x0</span>,(<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="number">0x0</span>,(<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="number">0x0</span> &#125;;</span><br><span class="line">	btea(enc, n, key);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%x&quot;</span>, enc[i]);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">char</span> <span class="built_in">string</span>[] = <span class="string">&quot;67616c665858437b646e615f742b2b5f7d6165&quot;</span>;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">1</span>,j=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j += <span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (j == <span class="number">0</span> &amp;&amp; i == <span class="number">5</span>)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%c%c&quot;</span>, <span class="built_in">string</span>[i * <span class="number">8</span> - j - <span class="number">2</span>], <span class="built_in">string</span>[i * <span class="number">8</span> - j - <span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下面是python脚本，但是我看得不是很懂。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">enc = <span class="string">&#x27;CEBC406B7C3A95C0EF9B202091F70235231802C8E75656FA&#x27;</span>.decode(<span class="string">&#x27;hex&#x27;</span>)</span><br><span class="line"></span><br><span class="line">dec1 = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(enc)/<span class="number">3</span>):</span><br><span class="line">    j = len(enc)/<span class="number">3</span> - i - <span class="number">1</span></span><br><span class="line">    res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> enc[j*<span class="number">3</span>:j*<span class="number">3</span>+<span class="number">3</span>]:</span><br><span class="line">        tmp = ord(k)</span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> range(j):</span><br><span class="line">            tmp ^= ord(enc[l])</span><br><span class="line">        res += chr(tmp)</span><br><span class="line">    dec1 = res + dec1</span><br><span class="line"><span class="keyword">print</span> dec1.encode(<span class="string">&#x27;hex&#x27;</span>)</span><br><span class="line"></span><br><span class="line">dec2 = [<span class="string">&#x27;&#x27;</span>] * len(dec1)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(dec1)):</span><br><span class="line">    dec2[i] = dec1[i]</span><br><span class="line"></span><br><span class="line">box = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">16</span>,<span class="number">18</span>,<span class="number">21</span>,<span class="number">23</span>,<span class="number">20</span>,<span class="number">22</span>]</span><br><span class="line"><span class="keyword">print</span> len(box)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(box)):</span><br><span class="line">    dec2[i] = dec1[box[i]]</span><br><span class="line">dec3 = <span class="string">&#x27;&#x27;</span>.join(dec2)</span><br><span class="line"><span class="keyword">print</span> dec3.encode(<span class="string">&#x27;hex&#x27;</span>)     <span class="comment">#先异或再换位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line">_DELTA = <span class="number">0x9E3779B9</span>  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_long2str</span>(<span class="params">v, w</span>):</span>  </span><br><span class="line">    n = (len(v) - <span class="number">1</span>) &lt;&lt; <span class="number">2</span>  </span><br><span class="line">    <span class="keyword">if</span> w:  </span><br><span class="line">        m = v[<span class="number">-1</span>]  </span><br><span class="line">        <span class="keyword">if</span> (m &lt; n - <span class="number">3</span>) <span class="keyword">or</span> (m &gt; n): <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>  </span><br><span class="line">        n = m  </span><br><span class="line">    s = struct.pack(<span class="string">&#x27;&lt;%iL&#x27;</span> % len(v), *v)  </span><br><span class="line">    <span class="keyword">return</span> s[<span class="number">0</span>:n] <span class="keyword">if</span> w <span class="keyword">else</span> s  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_str2long</span>(<span class="params">s, w</span>):</span>  </span><br><span class="line">    n = len(s)  </span><br><span class="line">    m = (<span class="number">4</span> - (n &amp; <span class="number">3</span>) &amp; <span class="number">3</span>) + n  </span><br><span class="line">    s = s.ljust(m, <span class="string">&quot;\0&quot;</span>)  </span><br><span class="line">    v = list(struct.unpack(<span class="string">&#x27;&lt;%iL&#x27;</span> % (m &gt;&gt; <span class="number">2</span>), s))  </span><br><span class="line">    <span class="keyword">if</span> w: v.append(n)  </span><br><span class="line">    <span class="keyword">return</span> v  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span>(<span class="params">str, key</span>):</span>  </span><br><span class="line">    <span class="keyword">if</span> str == <span class="string">&#x27;&#x27;</span>: <span class="keyword">return</span> str  </span><br><span class="line">    v = _str2long(str, <span class="literal">True</span>)  </span><br><span class="line">    k = _str2long(key.ljust(<span class="number">16</span>, <span class="string">&quot;\0&quot;</span>), <span class="literal">False</span>)  </span><br><span class="line">    n = len(v) - <span class="number">1</span>  </span><br><span class="line">    z = v[n]  </span><br><span class="line">    y = v[<span class="number">0</span>]  </span><br><span class="line">    sum = <span class="number">0</span>  </span><br><span class="line">    q = <span class="number">6</span> + <span class="number">52</span> // (n + <span class="number">1</span>)  </span><br><span class="line">    <span class="keyword">while</span> q &gt; <span class="number">0</span>:  </span><br><span class="line">        sum = (sum + _DELTA) &amp; <span class="number">0xffffffff</span>  </span><br><span class="line">        e = sum &gt;&gt; <span class="number">2</span> &amp; <span class="number">3</span>  </span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> xrange(n):  </span><br><span class="line">            y = v[p + <span class="number">1</span>]  </span><br><span class="line">            v[p] = (v[p] + ((z &gt;&gt; <span class="number">5</span> ^ y &lt;&lt; <span class="number">2</span>) + (y &gt;&gt; <span class="number">3</span> ^ z &lt;&lt; <span class="number">4</span>) ^ (sum ^ y) + (k[p &amp; <span class="number">3</span> ^ e] ^ z))) &amp; <span class="number">0xffffffff</span>  </span><br><span class="line">            z = v[p]  </span><br><span class="line">        y = v[<span class="number">0</span>]  </span><br><span class="line">        v[n] = (v[n] + ((z &gt;&gt; <span class="number">5</span> ^ y &lt;&lt; <span class="number">2</span>) + (y &gt;&gt; <span class="number">3</span> ^ z &lt;&lt; <span class="number">4</span>) ^ (sum ^ y) + (k[n &amp; <span class="number">3</span> ^ e] ^ z))) &amp; <span class="number">0xffffffff</span>  </span><br><span class="line">        z = v[n]  </span><br><span class="line">        q -= <span class="number">1</span>  </span><br><span class="line">    <span class="keyword">return</span> _long2str(v, <span class="literal">False</span>)  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span>(<span class="params">str, key</span>):</span>  </span><br><span class="line">    <span class="keyword">if</span> str == <span class="string">&#x27;&#x27;</span>: <span class="keyword">return</span> str  </span><br><span class="line">    v = _str2long(str, <span class="literal">False</span>)  </span><br><span class="line">    k = _str2long(key.ljust(<span class="number">16</span>, <span class="string">&quot;\0&quot;</span>), <span class="literal">False</span>)  </span><br><span class="line">    n = len(v) - <span class="number">1</span>  </span><br><span class="line">    z = v[n]  </span><br><span class="line">    y = v[<span class="number">0</span>]  </span><br><span class="line">    q = <span class="number">6</span> + <span class="number">52</span> // (n + <span class="number">1</span>)  </span><br><span class="line">    sum = (q * _DELTA) &amp; <span class="number">0xffffffff</span>  </span><br><span class="line">    <span class="keyword">while</span> (sum != <span class="number">0</span>):  </span><br><span class="line">        e = sum &gt;&gt; <span class="number">2</span> &amp; <span class="number">3</span>  </span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> xrange(n, <span class="number">0</span>, <span class="number">-1</span>):  </span><br><span class="line">            z = v[p - <span class="number">1</span>]  </span><br><span class="line">            v[p] = (v[p] - ((z &gt;&gt; <span class="number">5</span> ^ y &lt;&lt; <span class="number">2</span>) + (y &gt;&gt; <span class="number">3</span> ^ z &lt;&lt; <span class="number">4</span>) ^ (sum ^ y) + (k[p &amp; <span class="number">3</span> ^ e] ^ z))) &amp; <span class="number">0xffffffff</span>  </span><br><span class="line">            y = v[p]  </span><br><span class="line">        z = v[n]  </span><br><span class="line">        v[<span class="number">0</span>] = (v[<span class="number">0</span>] - ((z &gt;&gt; <span class="number">5</span> ^ y &lt;&lt; <span class="number">2</span>) + (y &gt;&gt; <span class="number">3</span> ^ z &lt;&lt; <span class="number">4</span>) ^ (sum ^ y) + (k[<span class="number">0</span> &amp; <span class="number">3</span> ^ e] ^ z))) &amp; <span class="number">0xffffffff</span>  </span><br><span class="line">        y = v[<span class="number">0</span>]  </span><br><span class="line">        sum = (sum - _DELTA) &amp; <span class="number">0xffffffff</span>  </span><br><span class="line">    <span class="keyword">return</span> _long2str(v, <span class="literal">True</span>)   <span class="comment">#这上面啥高端语法啊</span></span><br><span class="line"></span><br><span class="line">key = <span class="string">&#x27;flag&#x27;</span></span><br><span class="line">dec4 = decrypt(dec3, key)</span><br><span class="line"><span class="keyword">print</span> len(dec4)</span><br><span class="line"><span class="keyword">print</span> dec4</span><br></pre></td></tr></table></figure>

<p>似乎python3.版本不支持这种写法，也不知道是不是我编译器没装好。</p>
<p>实际上python还有xxtea库，但是有巨佬写出解密过程，那我就多学习学习。（一头雾水）</p>
<p>得出flag</p>
<p>flag{CXX_and_++tea}</p>
<p>估计得花几个星期消化。本以为只是稍微难一点的题目（也许真的是，只是我太菜了？）</p>
<p>反思：尝试一次特难题，实际上有好多东西难以理解，这次做下来只是大致了解。原本以为自己基本能看懂c和python语法，结果发现自己这一方面也有很大的欠缺。这么长的伪代码分析真的是折磨。而且自己根本写不出脚本。抽空学习python、C、汇编。内存动态分配是啥意思啥作用啊😫</p>
<p>参考博客：</p>
<p><a href="https://blog.csdn.net/Palmer9/article/details/103992451">https://blog.csdn.net/Palmer9/article/details/103992451</a></p>
<p><a href="https://impakho.com/post/redhat-2019-online-writeup">https://impakho.com/post/redhat-2019-online-writeup</a></p>
]]></content>
      <tags>
        <tag>逆向</tag>
        <tag>难题</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次IDA7.0插件安装过程</title>
    <url>/2020/10/12/%E8%AE%B0%E4%B8%80%E6%AC%A1IDA%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="记一次IDA7-0插件安装过程"><a href="#记一次IDA7-0插件安装过程" class="headerlink" title="记一次IDA7.0插件安装过程"></a>记一次IDA7.0插件安装过程</h1><p>插件：findcrypt</p>
<p>安装了很久，浪费了许多时间。这倒没什么，主要是因为tmd磨人心智。</p>
<h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><p>因为我的IDA是看雪学院下载的破解版本（似乎和吾爱破解的一样），所以自带python27文件夹，这是IDA许多插件所引用的python版本。然后findcrypt插件需要python的yara-python插件，这就搞得很麻烦。因此首先我们要编辑环境变量，再打开CMD用pip下载yara-python插件。如果电脑有装其他版本的Python，则需要先删去其他版本的环境变量，否则插件会错装到另外版本上去。（装好后再把其他版本的环境变量还原）</p>
<p><img src="https://gitee.com/onm1wa1/photo/raw/master/image-20201011231724807.png" alt="image-20201011231724807"></p>
<h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><p>重点在于检索资料的时候，我发现很多博客都说如果IDA有python27\Scripts，可以直接用pip安装，然后把findcrypt插件装进去就好了。结果我整半天都搞不好，每次要用pip安装时就提示找不到。</p>
<p><code> [Fatal error in launcher: Unable to create process using]</code></p>
<p>我本以为是我路径没设置好，或者路径名称太长了，或者是其他库没有装好。</p>
<p>后来一次尝试发现，我得再装一遍pip。气死。不知道哪里出问题了，反正重装了一遍。</p>
<p>首先要去网站下python2.7的setools</p>
<p>如上图，首先添加我的IDA 7.0连带安装的python 2.7-x64环境变量到path，之后安装setuptools，因为要安装pip，必须先安装setuptools，它的安装命令：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python setup.py install</span><br></pre></td></tr></table></figure>

<p>setup.py是解压之后可以看到的文件，命令行执行时一定要在切换到解压目录下（shift+鼠标右键），不然会提示找不到文件。</p>
<p>然后安装pip</p>
<p>首先去官网下载pip-10.0.1.tar.gz文件，下载链接：<a href="https://pypi.org/project/pip/#files%EF%BC%8C%E8%A7%A3%E5%8E%8B%E4%B9%8B%E5%90%8E%E5%88%87%E6%8D%A2%E5%88%B0%E8%AF%A5%E7%9B%AE%E5%BD%95%E4%B9%8B%E5%90%8E%EF%BC%8C%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%89%A7%E8%A1%8C%E4%BB%A5%E4%B8%8B%E5%91%BD%E4%BB%A4%EF%BC%9A">https://pypi.org/project/pip/#files，解压之后切换到该目录之后，用命令行执行以下命令：</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python setup.py install</span><br></pre></td></tr></table></figure>

<p>直到出现Finished processing dependencies for pip==10.0.1（随便什么版本均可），才算是安装成功。</p>
<h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><p>鉴于我的失败经验，把所有的库也重装了一遍。</p>
<p><a href="https://blog.csdn.net/tszupup/article/details/83536673">VC++14.0</a></p>
<p><a href="https://www.microsoft.com/en-us/download/details.aspx?id=44266">Vc++ compiler for python2.7支持库</a></p>
<h3 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h3><p>确认环境变量设置好后，任意位置</p>
<p><code>pip install yara-python==3.11.0</code></p>
<p>最新的yara不再支持python2了，在windows下使用pip安装的时候实际上不是用wheel来安装。必须得指定3.11.0版本才能安装成功</p>
<p>结果又出现错误</p>
<p><code>Could not install packages due to an EnvironmentError: HTTPSConnectionPool(host= &#39;files.pythonhosted.org&#39;, port=443): Max retries exceeded with url: /packages/96 /af/03015aec2c11a1e6b2221cb82e01bc5d153bb0813b044ca0da50d3d9a1f9/pycryptodome-3. 9.4-cp37-cp37m-win_amd64.whl (Caused by ReadTimeoutError(&quot;HTTPSConnectionPool(ho st=&#39;files.pythonhosted.org&#39;, port=443): Read timed out. (read timeout=15)&quot;))</code></p>
<p>解决方法</p>
<p>在本地创建：<br>C:\Users\Administrator\pip</p>
<p>pip.ini 文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line"></span><br><span class="line">trusted-host&#x3D;mirrors.aliyun.com</span><br><span class="line"></span><br><span class="line">index-url&#x3D;http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;pypi&#x2F;simple&#x2F;</span><br></pre></td></tr></table></figure>

<p>就能成功解决</p>
<p>（这我不太能理解为什么，似乎是源文件地址外网连不上了，所以转到一个镜像地址下载？）</p>
<h3 id="5"><a href="#5" class="headerlink" title="5."></a>5.</h3><p>下载来findcrpyt插件</p>
<p><img src="https://gitee.com/onm1wa1/photo/raw/master/image-20201011233317939.png" alt="image-20201011233317939"></p>
<p>把这两个复制进ida的plugin文档就完事了！再打开ida，edit中plugins就能看到findcrypt插件。</p>
<p>记得把环境变量改回来。</p>
<p>明明步骤很简单，但就是横生出好多问题。（抹泪）</p>
<p>实用参考：</p>
<p><a href="https://blog.csdn.net/userpass_word/article/details/80484467">插件安装流程</a></p>
<p><a href="https://blog.csdn.net/weixin_41782332/article/details/103673797">pip安装错误</a></p>
]]></content>
      <tags>
        <tag>插件安装</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向练习#6</title>
    <url>/2020/10/14/%5BBUUCTF-SimpleRev%5D/</url>
    <content><![CDATA[<h1 id="BUUCTF-SimpleRev"><a href="#BUUCTF-SimpleRev" class="headerlink" title="[BUUCTF-SimpleRev]"></a>[BUUCTF-SimpleRev]</h1><h4 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h4><p>放进exeinfo查看信息，是elf文件，丢尽IDA64位。</p>
<h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><p>搜索关键字段进入主要函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">Decry</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> v1; <span class="comment">// [rsp+Fh] [rbp-51h]</span></span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// [rsp+10h] [rbp-50h]</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// [rsp+14h] [rbp-4Ch]</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+18h] [rbp-48h]</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// [rsp+1Ch] [rbp-44h]</span></span><br><span class="line">  <span class="keyword">char</span> src[<span class="number">8</span>]; <span class="comment">// [rsp+20h] [rbp-40h]</span></span><br><span class="line">  __int64 v7; <span class="comment">// [rsp+28h] [rbp-38h]</span></span><br><span class="line">  <span class="keyword">int</span> v8; <span class="comment">// [rsp+30h] [rbp-30h]</span></span><br><span class="line">  __int64 v9; <span class="comment">// [rsp+40h] [rbp-20h]</span></span><br><span class="line">  __int64 v10; <span class="comment">// [rsp+48h] [rbp-18h]</span></span><br><span class="line">  <span class="keyword">int</span> v11; <span class="comment">// [rsp+50h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v12; <span class="comment">// [rsp+58h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v12 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  *(_QWORD *)src = &#x27;SLCDN&#x27;;</span><br><span class="line">  v7 = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  v8 = <span class="number">0</span>;</span><br><span class="line">  v9 = &#x27;wodah&#x27;;</span><br><span class="line">  v10 = <span class="number">0L</span>L;</span><br><span class="line">  v11 = <span class="number">0</span>;</span><br><span class="line">  text = join(key3, (<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;v9); <span class="comment">//join是自定义函数，简单的把两个字符串拼接</span></span><br><span class="line">                                            <span class="comment">//即在key3后面增添V9，text=&#x27;killshadow&#x27;</span></span><br><span class="line">  <span class="built_in">strcpy</span>(key, key1);</span><br><span class="line">  <span class="built_in">strcat</span>(key, src);                   <span class="comment">//key=&quot;ADSFKNDCLS&quot;</span></span><br><span class="line">  v2 = <span class="number">0</span>;</span><br><span class="line">  v3 = <span class="number">0</span>;</span><br><span class="line">  getchar();</span><br><span class="line">  v5 = <span class="built_in">strlen</span>(key);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; v5; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( key[v3 % v5] &gt; <span class="number">64</span> &amp;&amp; key[v3 % v5] &lt;= <span class="number">90</span> )  </span><br><span class="line">                                            <span class="comment">//if(key[v3]&gt;64 &amp;&amp; key[v3]&lt;=90)</span></span><br><span class="line">        <span class="comment">//把key每一位大写变小写</span></span><br><span class="line">      key[i] = key[v3 % v5] + <span class="number">32</span>;</span><br><span class="line">    ++v3;</span><br><span class="line">  &#125;  <span class="comment">//这个v3不知道做什么的</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Please input your flag:&quot;</span>, src);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v1 = getchar();</span><br><span class="line">    <span class="keyword">if</span> ( v1 == <span class="string">&#x27;\n&#x27;</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v1 == <span class="string">&#x27; &#x27;</span> )    <span class="comment">//遍历字符，是换行符结束，进入下一个判断：空格跳过</span></span><br><span class="line">    &#123;</span><br><span class="line">      ++v2;  <span class="comment">//v2表示字符串中字符的位号，这里判断是空格，于是+1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v1 &lt;= <span class="string">&#x27;`&#x27;</span> || v1 &gt; <span class="string">&#x27;z&#x27;</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( v1 &gt; <span class="string">&#x27;@&#x27;</span> &amp;&amp; v1 &lt;= <span class="string">&#x27;Z&#x27;</span> )</span><br><span class="line">          str2[v2] = (v1 - <span class="number">39</span> - key[v3++ % v5] + <span class="number">97</span>) % <span class="number">26</span> + <span class="number">97</span>; <span class="comment">//v2是会逐增的</span></span><br><span class="line">                                       <span class="comment">//str2[v2] = (v1-key[v3]+58)%26 + 97</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        str2[v2] = (v1 - <span class="number">39</span> - key[v3++ % v5] + <span class="number">97</span>) % <span class="number">26</span> + <span class="number">97</span>;   </span><br><span class="line">                                      <span class="comment">//以上为加密操作，所以我们根据这些反推。</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( !(v3 % v5) )  <span class="comment">//如果循环到key的最后一位</span></span><br><span class="line">        <span class="built_in">putchar</span>(<span class="number">32</span>);     <span class="comment">//输出空格</span></span><br><span class="line">      ++v2;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(text, str2) )    <span class="comment">//与text对比</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Congratulation!\n&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Try again!\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v12;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>key3跟进，是字符串”kills”。key1是”ADSFK”。</p>
<p>由于字符串小端序存储，反过来写，所以注释中text与key是这个结果。</p>
<p><strong>一般来说，x86系列cpu都是小端序存储，大端序一般用于网络协议。</strong></p>
<p>经验：遇到不明数字最好转换成char类型看看，不然可能会找不到解题关键。</p>
<h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><p>写解密脚本</p>
<p>本来想着自己独立写的，但耗时许久没有成功，取余逆运算是知识盲区。</p>
<p> 如：A=(B-C)%D<br>    那么B=(A+C)%D     </p>
<p> 推倒过程：</p>
<p>​       比如假设都是正整数<br>​       A=(B-C)%D<br>​       则 B - C = D*n + A 其中 A &lt; D</p>
<p>​       移项 B = A+C + D<em>n<br>​      当B&lt;D时，两边对D取摸，<br>​      B = B%D = ( A+C + D</em>n )%D = (A+C)%D                      </p>
<p>好家伙，正好最近在学信安数学原理。但需要猜测D的存在。</p>
<p>于是python脚本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">text = <span class="string">&#x27;killshadow&#x27;</span></span><br><span class="line">key = <span class="string">&#x27;adsfkndcls&#x27;</span></span><br><span class="line">key_ = <span class="string">&#x27;&#x27;</span></span><br><span class="line">v3=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(key)):</span><br><span class="line">        flag = ord(key[v3%len(key)])</span><br><span class="line">        <span class="keyword">if</span> flag &gt; <span class="number">64</span> <span class="keyword">and</span> flag &lt;=<span class="number">90</span>:</span><br><span class="line">                key_ += chr(ord(key[v3%len(key)])+<span class="number">32</span>)</span><br><span class="line">        v3=v3+<span class="number">1</span>                        <span class="comment">#这一段for循环是大小写变换，可以不要</span></span><br><span class="line">ans = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(key)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">15</span>):  <span class="comment">#算是爆破？</span></span><br><span class="line">                tmp=chr(ord(text[i]) - <span class="number">97</span> + <span class="number">26</span>*j - <span class="number">97</span> + ord(key [v3%len(key)]) + <span class="number">39</span>)</span><br><span class="line">                <span class="keyword">if</span> ord(tmp)&gt;<span class="number">64</span> <span class="keyword">and</span> ord(tmp) &lt;<span class="number">91</span>: <span class="comment">#试对了的正确结果输出</span></span><br><span class="line">                        ans+=tmp</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">        v3=v3+<span class="number">1</span></span><br><span class="line"><span class="keyword">print</span> (ans)</span><br></pre></td></tr></table></figure>

<p>网上扒来的</p>
<p>疑惑：为什么是key [v3%len(key)]，大概是顺应伪代码的原意。</p>
<p>自我缩减版</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">text = <span class="string">&#x27;killshadow&#x27;</span></span><br><span class="line">key = <span class="string">&#x27;adsfkndcls&#x27;</span></span><br><span class="line">ans = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(key)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">15</span>):</span><br><span class="line">                tmp=chr(ord(text[i]) - <span class="number">97</span> + <span class="number">26</span>*j - <span class="number">97</span> + ord(key[i]) + <span class="number">39</span>)</span><br><span class="line">                <span class="keyword">if</span> ord(tmp)&gt;<span class="number">64</span> <span class="keyword">and</span> ord(tmp) &lt;<span class="number">91</span>:</span><br><span class="line">                        ans+=tmp</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">print</span> (ans)</span><br></pre></td></tr></table></figure>

<p>不知为什么这个脚本能确定结果必然是大写的，不过要是不确定加上if检查是否小写就行了。</p>
<p>应该是因为有大写变小写的操作。</p>
<p>得出结果：KLDQCUDFZO  </p>
<p>搞定！</p>
]]></content>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
</search>
